<!DOCTYPE html>
<html>
    <head>
        <title>fleximeter</title>
        <link href="css/stylesheet.css" rel="stylesheet"/>
    </head>
    <body>
        <header><h1><a href="index.html">fleximeter composition and analysis software</a></h1></header>
        <nav>
            <div class="navDiv">
                <a href="pctheory.html">pctheory</a>
                <a href="set-manipulator.html">SetManipulator</a>
                <a href="additional.html">Additional Software</a>
                <a href="doc.html">Documentation</a>
                <a href="about.html">About</a>
                <a href="https://jeffreymartincomposer.com/">Composer Website</a>
            </div>
        </nav>

        <div class="mainDiv">
            <div class="article">
                <h2>3.5. pctheory.pcset</h2>
                <p>
                    This module contains classes and functions for working with pcsets, or sets of
                    pitch-classes. A pcset is represented as a <span class="code pyKeyword">set</span>
                    of <span class="code pyClass">PitchClass12</span> or <span class="code pyClass">PitchClass24</span>
                    elements.
                </p>
                <p>
                    Functions marked with * can be used with chromatic or microtonal pcsets.
                </p>
                <div class="codeReference">
                    <h4><span class="code"><span class="pyKeyword">class</span> <span class="pyClass">SetClass12</span></span></h4>
                    <p>
                        Represents a pitch-class set-class with elements drawn from the twelve-note equally-tempered chromatic scale.
                        Notes are represented with <span class="code pyClass">PitchClass12</span> objects. There are 224
                        set-classes in the chromatic system, including the null set-class.
                    </p>
                    <div class="codeIndent1Reference">
                        <h4><span class="subhead"><span class="code pyClass">SetClass12</span> constructor</span></h4>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.__init__(pcset: <span class="pyKeyword">set</span>)</span></h5>
                        <p>
                            Constructs a <span class="code pyClass">SetClass12</span>. You can provide a pcset to initialize the 
                            <span class="code pyClass">SetClass12</span>.
                        </p>
                        <h4><span class="subhead"><span class="code pyClass">SetClass12</span> properties</span></h4>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.pcset<span class="returnType">{<span class="pyClass">PitchClass12</span>}</span></span></h5>
                        <p>
                            The prime-form pcset of the current <span class="code pyClass">SetClass12</span>. If you assign a pcset
                            to this property, the <span class="code pyClass">SetClass12</span> will automatically calculate
                            its prime form and update the <span class="code pyClass">SetClass12</span><span class="code">.pcset</span> properly.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.weight_right<span class="returnType pyKeyword">bool</span></span></h5>
                        <p>
                            Whether or not the prime form should be calculated by packing from the right.
                        </p>   
                        <h4><span class="subhead"><span class="code pyClass">SetClass12</span> read-only properties</span></h4>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.derived_core<span class="returnType pyKeyword">bool</span></span></h5>
                        <p>
                            Whether or not the current <span class="code pyClass">SetClass12</span> is one of Elliott Carter&apos;s &ldquo;derived core&rdquo; harmonies,
                            as specified by John Link.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.dsym<span class="returnType pyKeyword">int</span><span class="code"></span></h5>
                        <p>
                            The degree of symmetry of the <span class="code pyClass">SetClass12</span>. This is the number of 
                            T<sub><i>n</i></sub> and T<sub><i>n</i></sub>I transformations which will transform a
                            member of the set-class into itself. Many set-classes have a degree of symmetry of 1,
                            which means that there are 24 pcsets in the set-class. The whole-tone scale has a
                            degree of symmetry of 12 because there are only two whole-tone scales. The chromatic scale
                            has a degree of symmetry of 24 because it is invariant under all of the T<sub><i>n</i></sub> and T<sub><i>n</i></sub>I
                            transformations.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.ic_vector<span class="returnType">[<span class="pyKeyword">int</span>]</span></span></h5>
                        <p>
                            The ic vector of the current <span class="code pyClass">SetClass12</span> as a <span class="code pyKeyword">list</span> of 
                            <span class="code pyKeyword">int</span>s.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.ic_vector_str<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            The ic vector of the current <span class="code pyClass">SetClass12</span> as a <span class="code pyKeyword">str</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.ic_vector_long<span class="returnType">[<span class="pyKeyword">int</span>]</span></span></h5>
                        <p>
                            The long form of the ic vector of the current <span class="code pyClass">SetClass12</span> as a <span class="code pyKeyword">list</span> of 
                            <span class="code pyKeyword">int</span>s. The long form has an extra leading digit with the cardinality of the set-class.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.ic_vector_long_str<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            The long form of the ic vector of the current <span class="code pyClass">SetClass12</span> as a <span class="code pyKeyword">str</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.is_z_relation<span class="returnType pyKeyword">bool</span></span></h5>
                        <p>
                            Whether or not the current <span class="code pyClass">SetClass12</span> is Z-related to another class.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.name_carter<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            Returns the Carter number for the current <span class="code pyClass">SetClass12</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.name_forte<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            Returns the Forte name for the current <span class="code pyClass">SetClass12</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.name_morris<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            Returns the Morris name for the current <span class="code pyClass">SetClass12</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.name_prime<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            Returns the prime form name for the current <span class="code pyClass">SetClass12</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.num_forte<span class="returnType pyKeyword">int</span></span></h5>
                        <p>
                            Returns the Forte number (the part after the hyphen) for the current <span class="code">SetClass12</span>.
                        </p>
                        <h4><span class="subhead"><span class="code pyClass">SetClass12</span> methods</span></h4>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.calculate_prime_form(pcset: <span class="pyKeyword">set</span>, weight_from_right: <span class="pyKeyword">bool</span> = <span class="pyKeyword">True</span>)<span class="returnType">[<span class="pyClass">PitchClass12</span>]</span></span></h5>
                        <p>
                            Calculates the prime form of a provided pcset. Pcsets are Python <span class="code">set</span>
                            objects containing <span class="code pyClass">PitchClass12</span> elements. The 
                            <span class="code">weight_from_right</span> parameter determines if the prime form will be packed
                            from the right (Rahn) or packed to the left (Forte). This produces different prime forms in only
                            a few set-classes.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.contains_abstract_subset(sc: <span class="pyClass">SetClass12</span>)<span class="returnType pyKeyword">bool</span></span></h5>
                        <p>
                            Determines if a set-class <span class="code">sc</span> is an abstract subset of the current
                            <span class="code pyClass">SetClass12</span> object. Returns <span class="code pyKeyword">True</span> or
                            <span class="code pyKeyword">False</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.get_abstract_complement()<span class="returnType pyClass">SetClass12</span></span></h5>
                        <p>
                            Returns the abstract complement of the current <span class="code pyClass">SetClass12</span> object.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.get_invariance_vector()<span class="returnType">[<span class="pyKeyword">int</span>]</span></span></h5>
                        <p>
                            Returns the invariance vector of the current <span class="code pyClass">SetClass12</span> object.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.get_partition2_subset_classes()<span class="returnType">{(<span class="pyClass">SetClass12</span>, <span class="pyClass">SetClass12</span>)}</span></span></h5>
                        <p>
                            Returns a <span class="code pyKeyword">set</span> of <span class="code pyClass">SetClass12</span> 
                            <span class="code pyKeyword">tuple</span> objects containing all two-partitions of the current
                            set-class. Particularly applicable to the music of Milton Babbitt.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.get_set_classes()<span class="returnType">[<span class="pyClass">SetClass12</span>]</span></span></h5>
                        <p>
                            Returns a <span class="code pyKeyword">list</span> of all 224 <span class="code pyClass">SetClass12</span>s.
                        </p>
                        <h5><span class="code">&#x40;staticmethod<span class="pyClass">SetClass12</span>.get_abstract_subset_classes()</span><span class="returnType">{<span class="pyClass">SetClass12</span>}</span></span></h5>
                        <p>
                            Returns a <span class="code pyKeyword">set</span> of <span class="code pyClass">SetClass12</span> objects
                            representing all set-classes abstractly contained within the current set-class. 
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.get_z_relation()<span class="returnType pyClass">SetClass12</span></span></h5>
                        <p>
                            Returns a <span class="code pyClass">SetClass12</span> object
                            representing the Z-relation of the current set-class. If there is no Z-relation,
                            returns an empty <span class="code pyClass">SetClass12</span> object. 
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.is_all_combinatorial_hexachord()</span><span class="returnType code"><span class="pyKeyword">bool</span></span></h5>
                        <p>
                            Determines if the set&hyphen;class is an all&hyphen;combinatorial hexachord (ACH).
                        </p>    
                        <h5><span class="code">@staticmethod <span class="pyClass">SetClass12</span>.is_valid_name(name: <span class="pyKeyword">str</span>)<span class="returnType pyKeyword">bool</span></span></h5>
                        <p>
                            Determines if a provided set-class name is valid. Valid name types include <span class="code pyStr"><q>[xxx]</q></span> (prime form),
                            <span class="code pyStr"><q>x-x</q></span> (Forte), and <span class="code pyStr"><q>(x-x)[xxx]</q></span> (Morris).
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass12</span>.load_from_name(name: <span class="pyKeyword">str</span>)</span></h5>
                        <p>
                            Loads a set-class into the current <span class="code pyClass">SetClass12</span> object. The name
                            can be in prime-form, Forte, or Morris format.
                        </p>
                        <h4><span class="subhead"><span class="code pyClass">SetClass12</span> overloaded special functions</span></h4>
                        <p>
                            Overloaded special functions include <span class="code">__eq__()</span>, 
                            <span class="code">__hash__()</span>, <span class="code">__len__()</span>,
                            <span class="code">__lt__()</span>, <span class="code">__ne__()</span>,
                            <span class="code">__repr__()</span>, and <span class="code">__str__()</span>.
                            Basically, this means that you can use the <span class="code">==</span>, 
                            <span class="code">&lt;</span> and <span class="code">!=</span> operators
                            on <span class="code pyClass">SetClass12</span> objects. The &lt; operator
                            is implemented to allow sorting using built-in Python functionality. The
                            <span class="code">len()</span> function is supported, as well as
                            <span class="code">hash()</span> (which allows you to use 
                            <span class="code pyClass">SetClass12</span> objects in sets and dictionary keys),
                            and the <span class="code">str()</span> implementation allows 
                            <span class="code pyClass">SetClass12</span> objects to be printed.
                        </p>
                    </div>
                    <h4><span class="code"><span class="pyKeyword">class</span> <span class="pyClass">SetClass24</span></span></h4>
                    <p>
                        Represents a pitch-class set-class with elements drawn from the 24-note equally-tempered microtonal scale.
                        Notes are represented with <span class="code pyClass">PitchClass24</span> objects. There are 352,698
                        set-classes in the microtonal system, including the null set-class.
                    </p>
                    <div class="codeIndent1Reference">
                        <h4><span class="subhead"><span class="code pyClass">SetClass24</span> constructor</span></h4>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.__init__(pcset: <span class="pyKeyword">set</span>)</span></h5>
                        <p>
                            Constructs a <span class="code pyClass">SetClass24</span>. 
                            You may choose to provide a pcset to initialize the 
                            <span class="code pyClass">SetClass24</span>.
                        </p>
                        <h4><span class="subhead"><span class="code pyClass">SetClass24</span> properties</span></h4>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.pcset<span class="returnType">{<span class="pyClass">PitchClass24</span>}</span></span></h5>
                        <p>
                            The prime-form pcset of the current <span class="code pyClass">SetClass24</span>. If you assign a pcset
                            to this property, the <span class="code pyClass">SetClass24</span> will automatically calculate
                            its prime form and update the <span class="code pyClass">SetClass24</span><span class="code">.pcset</span> properly.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.weight_right<span class="returnType pyKeyword">bool</span></span></h5>
                        <p>
                            Whether or not the prime form should be calculated by packing from the right.
                        </p>   
                        <h4><span class="subhead"><span class="code pyClass">SetClass24</span> read-only properties</span></h4>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.dsym<span class="returnType pyKeyword">int</span></span></h5>
                        <p>
                            The degree of symmetry of the <span class="code pyClass">SetClass24</span>. This is the number of 
                            T<sub><i>n</i></sub> and T<sub><i>n</i></sub>I transformations which will transform a
                            member of the set-class into itself. Many set-classes have a degree of symmetry of 1,
                            which means that there are 48 pcsets in the set-class.
                        </p><h5><span class="code"><span class="pyClass">SetClass24</span>.ic_vector<span class="returnType">[<span class="pyKeyword">int</span>]</span></span></h5>
                        <p>
                            The ic vector of the current <span class="code pyClass">SetClass24</span> as a <span class="code pyKeyword">list</span> of 
                            <span class="code pyKeyword">int</span>s.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.ic_vector_str<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            The ic vector of the current <span class="code pyClass">SetClass24</span> as a <span class="code pyKeyword">str</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.ic_vector_long<span class="returnType">[<span class="pyKeyword">int</span>]</span></span></h5>
                        <p>
                            The long form of the ic vector of the current <span class="code pyClass">SetClass24</span> as a <span class="code pyKeyword">list</span> of 
                            <span class="code pyKeyword">int</span>s. The long form has an extra leading digit with the cardinality of the set-class.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.ic_vector_long_str<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            The long form of the ic vector of the current <span class="code pyClass">SetClass24</span> as a <span class="code pyKeyword">str</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.name_prime<span class="returnType pyKeyword">str</span></span></h5>
                        <p>
                            Returns the prime form name for the current <span class="code pyClass">SetClass24</span>.
                        </p>
                        <h4><span class="subhead"><span class="code pyClass">SetClass24</span> methods</span></h4>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.calculate_prime_form(pcset: <span class="pyKeyword">set</span>, weight_from_right: <span class="pyKeyword">bool</span> = <span class="pyKeyword">True</span>)<span class="returnType">{<span class="pyClass">PitchClass24</span>}</span></span></h5>
                        <p>
                            Calculates the prime form of a provided pcset. Pcsets are Python <span class="code">set</span>
                            objects containing <span class="code pyClass">PitchClass24</span> elements. The 
                            <span class="code">weight_from_right</span> parameter determines if the prime form will be packed
                            from the right (Rahn) or packed to the left (Forte). This produces different prime forms in only
                            a few set-classes.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.contains_abstract_subset(sc: <span class="pyClass">SetClass24</span>)<span class="returnType pyKeyword">bool</span></span></h5>
                        <p>
                            Determines if a set-class <span class="code">sc</span> is an abstract subset of the current
                            <span class="code pyClass">SetClass24</span> object. Returns <span class="code pyKeyword">True</span> or
                            <span class="code pyKeyword">False</span>.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.get_abstract_complement()<span class="returnType">{<span class="pyClass">PitchClass24</span>}</span></span></h5>
                        <p>
                            Returns the abstract complement of the current <span class="code pyClass">SetClass24</span> object.
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.get_abstract_subset_classes()<span class="returnType">{<span class="pyClass">SetClass24</span>}</span></span></h5>
                        <p>
                            Returns a <span class="code pyKeyword">set</span> of <span class="code pyClass">SetClass24</span> objects
                            representing all set-classes abstractly contained within the current set-class. 
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.is_valid_name(name: <span class="pyKeyword">str</span>)<span class="returnType pyKeyword">bool</span></span></h5>
                        <p>
                            Determines if a provided set-class name is valid. Valid name types include <span class="code pyStr"><q>[xxx]</q></span> (prime form).
                        </p>
                        <h5><span class="code"><span class="pyClass">SetClass24</span>.load_from_name(name: <span class="pyKeyword">str</span>)</span></h5>
                        <p>
                            Loads a set-class into the current <span class="code pyClass">SetClass24</span> object. The name
                            can be in prime-form format.
                        </p>
                        <h4><span class="subhead"><span class="code pyClass">SetClass24</span> overloaded special functions</span></h4>
                        <p>
                            Overloaded special functions include <span class="code">__eq__()</span>, 
                            <span class="code">__hash__()</span>, <span class="code">__len__()</span>,
                            <span class="code">__lt__()</span>, <span class="code">__ne__()</span>,
                            <span class="code">__repr__()</span>, and <span class="code">__str__()</span>.
                            Basically, this means that you can use the <span class="code">==</span>, 
                            <span class="code">&lt;</span> and <span class="code">!=</span> operators
                            on <span class="code pyClass">SetClass24</span> objects. The &lt; operator
                            is implemented to allow sorting using built-in Python functionality. The
                            <span class="code">len()</span> function is supported, as well as
                            <span class="code">hash()</span> (which allows you to use 
                            <span class="code pyClass">SetClass24</span> objects in sets and dictionary keys),
                            and the <span class="code">str()</span> implementation allows 
                            <span class="code pyClass">SetClass24</span> objects to be printed.
                        </p>
                    </div>
                    <h5><span class="code">*find_utos(pcset1: <span class="pyKeyword">set</span>, pcset2: <span class="pyKeyword">set</span>)</span><span class="returnType code">{<span class="pyClass">UTO</span>}</span></h5>
                    <p>
                        Finds all UTOs that transform <span class="code">pcset1</span> so that it contains <span class="code">pcset2</span>.
                        This function can be used to find individual pcs, subsets, or the entire transformed pcset.
                    </p>
                    <h5><span class="code">get_all_combinatorial_hexachord(name: <span class="pyKeyword">str</span>)</span><span class="returnType code">{<span class="pyClass">PitchClass12</span>}</span></h5>
                    <p>
                        Gets an all&hyphen;combinatorial hexachord (ACH) by name (A through F).
                    </p>
                    <h5><span class="code">*get_complement(pcset: <span class="pyKeyword">set</span>)</span><span class="returnType code">{<span class="pyClass">PitchClass12</span>}</span>or<span class="returnType2 code">{<span class="pyClass">PitchClass24</span>}</span></h5>
                    <p>
                        Gets the complement of a provided pcset. This is not the abstract complement of a set-class.
                    </p>
                    <h5><span class="code">*get_complement_map_utos(pcset: <span class="pyKeyword">set</span>)</span><span class="returnType code">{<span class="pyClass">UTO</span>}</span></h5>
                    <p>
                        Gets all <span class="code pyClass">UTO</span>s that map <span class="code">pcset</span> into its complement.
                    </p>
                    <h5><span class="code">*get_corpus(pcset: <span class="pyKeyword">set</span>)</span><span class="returnType code">{<span class="pyKeyword">frozenset</span>(<span class="pyClass">PitchClass12</span>)}</span>or<span class="returnType2 code">{<span class="pyKeyword">frozenset</span>(<span class="pyClass">PitchClass24</span>)}</span></h5>
                    <p>
                        Gets all UTO transformations of a provided pcset, as a <span class="code pyKeyword">set</span>.
                    </p>
                    <h5><span class="code">*get_self_map_utos(pcset: <span class="pyKeyword">set</span>)</span><span class="returnType code">{<span class="pyClass">UTO</span>}</span></h5>
                    <p>
                        Gets all <span class="code pyClass">UTO</span>s that map <span class="code">pcset</span> into itself.
                    </p>
                    <h5><span class="code">*invert(pcset: <span class="pyKeyword">set</span>)</span><span class="returnType code">{<span class="pyClass">PitchClass12</span>}</span>or<span class="returnType2 code">{<span class="pyClass">PitchClass24</span>}</span></h5>
                    <p>
                        Inverts a pcset by using the M<sub>11</sub> or M<sub>23</sub> operations, depending on
                        whether the pcset contains <span class="code pyClass">PitchClass12</span> or 
                        <span class="code pyClass">PitchClass24</span> elements.
                    </p>
                    <h5><span class="code">is_all_combinatorial_hexachord(pcset: <span class="pyKeyword">set</span>)</span><span class="returnType code"><span class="pyKeyword">bool</span></span></h5>
                    <p>
                        Determines if a pcset is an all&hyphen;combinatorial hexachord (ACH).
                    </p>
                    <h5><span class="code">make_pcset12(*args)<span class="returnType">{<span class="pyClass">PitchClass12</span>}</span></span></h5>
                    <p>
                        Creates a chromatic pcset from one or more <span class="code pyKeyword">int</span> values.
                    </p>
                    <h5><span class="code">make_pcset24(*args)<span class="returnType">{<span class="pyClass">PitchClass24</span>}</span></span></h5>
                    <p>
                        Creates a microtonal pcset from one or more <span class="code pyKeyword">int</span> values.
                    </p>
                    <h5><span class="code">*make_subset_graph(set_class, smallest_cardinality=1, show_graph=<span class="pyKeyword">False</span>, size=(800,1100))<span class="returnType">{networkx.<span class="pyClass">DiGraph</span>}</span></span></h5>
                    <p>
                        Makes a subset graph, using a provided <span class="code pyClass">SetClass12</span> or 
                        <span class="code pyClass">SetClass24</span>. If you choose to show the graph, it will be generated
                        as a PyVis visualization.
                    </p>
                    <h5><span class="code">*multiply(pcset: <span class="pyKeyword">set</span>, n: <span class="pyKeyword">int</span>)</span><span class="returnType code">{<span class="pyClass">PitchClass12</span>}</span>or<span class="returnType2 code">{<span class="pyClass">PitchClass24</span>}</span></h5>
                    <p>
                        Multiplies a pcset using the operator M<sub><i>n</i></sub>.
                    </p>
                    <h5><span class="code">*partitions2(pcset: <span class="pyKeyword">set</span>)</span><span class="returnType code">[({<span class="pyClass">PitchClass12</span>}, {<span class="pyClass">PitchClass12</span>})]</span>or<span class="returnType2 code">[({<span class="pyClass">PitchClass24</span>}, {<span class="pyClass">PitchClass24</span>})]</span></h5>
                    <p>
                        Gets a list of all two-partitions of a provided pcset. Each two-partition is a tuple of pcsets.
                    </p>
                    <h5><span class="code">set_class_filter12(name: <span class="pyKeyword">str</span>, sets: <span class="pyKeyword">list</span>)<span class="returnType">[{<span class="pyClass">PitchClass12</span>}]</span></span></h5>
                    <p>
                        Filters a list of chromatic pcsets. Returns a list that only contains pcsets in the set-class <span class="code">name</span>. 
                    </p>
                    <h5><span class="code">*subsets(pcset: <span class="pyKeyword">set</span>)</span><span class="returnType code">[{<span class="pyClass">PitchClass12</span>}]</span>or<span class="returnType2 code">[{<span class="pyClass">PitchClass24</span>}]</span></h5>
                    <p>
                        Generates all subsets of a provided pcset, and returns them in sorted order.
                    </p>
                    <h5><span class="code">*transpose(pcset: <span class="pyKeyword">set</span>, n: <span class="pyKeyword">int</span>)</span><span class="returnType code">{<span class="pyClass">PitchClass12</span>}</span>or<span class="returnType2 code">{<span class="pyClass">PitchClass24</span>}</span></h5>
                    <p>
                        Transposes a pcset using the operator T<sub><i>n</i></sub>.
                    </p>
                    <h5><span class="code">*visualize(pcset: <span class="pyKeyword">set</span>)</span></h5>
                    <p>
                        Creates a string visualization of a pcset. The string has length 12 or 24, and contains <span class="code pyStr">&quot;X&quot;</span>
                        or a space for each of the 12 or 24 pitch-classes, depending on whether or not that pitch-class is present.
                        This function is useful for inspecting pcsets visually for common tones.
                    </p>
                </div>
            </div>
            <aside class="sidebar">
                <h3>Documentation for pctheory</h3>
                <hr/>
                <p><a href="pc-pctheory.html">1. Introduction</a></p>
                <p><a href="pc-pctheoryintro.html">2. Atonal theory</a></p>
                <p><a href="pc-pctheorym.html">3. pctheory module reference</a></p>
                <div class="indent1">
                    <p><a href="pc-pctheory-array.html">3.1. pctheory.array</a></p>
                    <p><a href="pc-pctheory-cseg.html">3.2. pctheory.cseg</a></p>
                    <p><a href="pc-pctheory-group.html">3.3. pctheory.group</a></p>
                    <p><a href="pc-pctheory-pcseg.html">3.4. pctheory.pcseg</a></p>
                    <p><a href="pc-pctheory-pcset.html">3.5. pctheory.pcset</a></p>
                    <p><a href="pc-pctheory-pitch.html">3.6. pctheory.pitch</a></p>
                    <p><a href="pc-pctheory-poset.html">3.7. pctheory.poset</a></p>
                    <p><a href="pc-pctheory-pseg.html">3.8. pctheory.pseg</a></p>
                    <p><a href="pc-pctheory-pset.html">3.9. pctheory.pset</a></p>
                    <p><a href="pc-pctheory-set_complex.html">3.10. pctheory.set_complex</a></p>
                    <p><a href="pc-pctheory-tables.html">3.11. pctheory.tables</a></p>
                    <p><a href="pc-pctheory-tempo.html">3.12. pctheory.tempo</a></p>
                    <p><a href="pc-pctheory-transformations.html">3.13. pctheory.transformations</a></p>
                    <p><a href="pc-pctheory-util.html">3.14. pctheory.util</a></p>
                </div>
            </aside>
        </div>

        <footer>
            <div class="footerDiv">
                <p>
                    Copyright &copy;2022 by Jeffrey Martin. All rights reserved. <a href="https://jeffreymartincomposer.com/">https://jeffreymartincomposer.com/</a>
                </p>
            </div>
        </footer>
    </body>
</html>